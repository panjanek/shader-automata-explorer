#version 430 core

#pragma optimize(on)

layout(local_size_x = {LocalSizeX}) in;

struct SpeciesConfig
{
    float velocity;
    float turnSpeed;
    float sensorAngle;
    float sensorDistance;
    int sensorSize;
    float attractionTreshold;
    float repulsionTreshold;
};

struct ShaderConfig {
    int agentsCount;
    int width;
    int height;
    int time;
    SpeciesConfig species_r;
    SpeciesConfig species_g;
    SpeciesConfig species_b;
};

struct Agent
{
    vec2 position;
    float angle;
    uint species;
};

layout(std430, binding = 0) buffer ConfigBuffer {
    ShaderConfig config;
};

layout(std430, binding = 1) buffer OutputBuffer {
    Agent agents[];
};

layout(rgba32f, binding = 3) uniform image2D uStateImage;

void torus(inout vec2 pos)
{
    if (pos.x > config.width)
        pos.x -= config.width;
    else if (pos.x < 0)
        pos.x += config.width;

    if (pos.y > config.height)
        pos.y -= config.height;
    else if (pos.y < 0)
        pos.y += config.height;
}

void itorus(inout ivec2 pos)
{
    if (pos.x > config.width)
        pos.x -= config.width;
    else if (pos.x < 0)
        pos.x += config.width;

    if (pos.y > config.height)
        pos.y -= config.height;
    else if (pos.y < 0)
        pos.y += config.height;
}

uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scaleToRange01(uint state)
{
    return state / 4294967295.0;
}

vec4 sense(Agent agent, float sensorAngle, float sensorDist, int sensorSize)
{
    float sensingAngle = agent.angle + sensorAngle;
    vec2 sensingDir = vec2(cos(sensingAngle),sin(sensingAngle));
    vec2 sensingCenter = agent.position + sensingDir * sensorDist;
    ivec2 center = ivec2(int(sensingCenter.x),int(sensingCenter.y));
    vec4 sum = vec4(0,0,0,0);
    for(int offsetX=-sensorSize; offsetX <= sensorSize; offsetX++)
        for(int offsetY=-sensorSize; offsetY <= sensorSize; offsetY++)
        {
            ivec2 sensePixel = center + ivec2(offsetX, offsetY);
            itorus(sensePixel);
            sum += imageLoad(uStateImage, sensePixel);
        }

    uint r = 2*sensorSize+1;
    return sum / (r*r);
}

//https://github.com/SebLague/Slime-Simulation/blob/main/Assets/Scripts/Slime/SlimeSim.compute

void update_one(uint idx)
{
    Agent agent = agents[idx];
    SpeciesConfig spec = config.species_r;
    if (agent.species == 1)
        spec = config.species_g;
    else if (agent.species == 2)
        spec = config.species_b;

    vec4 sense_left = sense(agent, -spec.sensorAngle, spec.sensorDistance, spec.sensorSize);
    vec4 sense_forward = sense(agent, 0, spec.sensorDistance, spec.sensorSize);
    vec4 sense_right = sense(agent, spec.sensorAngle, spec.sensorDistance, spec.sensorSize);

    float left = sense_left.r;
    float forward = sense_forward.r;
    float right = sense_right.r;
    if (agent.species == 1)
    {
        left = sense_left.g;
        forward = sense_forward.g;
        right = sense_right.g;
    }
    else if (agent.species == 2)
    {
        left = sense_left.b;
        forward = sense_forward.b;
        right = sense_right.b;
    }

    float left_opp = max(sense_left.g, sense_left.b);
    float forward_opp = max(sense_forward.g, sense_forward.b);
    float right_opp = max(sense_right.g, sense_right.b);
    if (agent.species == 1)
    {
        left_opp = max(sense_left.r, sense_left.b);
        forward_opp = max(sense_forward.r, sense_forward.b);
        right_opp = max(sense_right.r, sense_right.b);
    }
    else if (agent.species == 2)
    {
        left_opp = max(sense_left.r, sense_left.g);
        forward_opp = max(sense_forward.r, sense_forward.g);
        right_opp = max(sense_right.r, sense_right.g);
    }

    uint random =  hash(uint(agent.position.y * config.width + agent.position.x) + hash(gl_GlobalInvocationID.x + config.time * 100000));
    float random01 = scaleToRange01(random);
    float random1 = random01 * 0.3 + 0.85;

    float angleDelta = 0;
    float sense_max = max(forward, max(left, right));
    if (forward > left && forward > right)
    {
        angleDelta += 0;              
    }
    else if (sense_max < spec.attractionTreshold)
    {
        angleDelta += (random01 - 0.5) * 2 * spec.turnSpeed;    //random because there is no strong trail
    }
    else
    {
        angleDelta += spec.turnSpeed * random1 * (right - left);    //attract
    }

    //repulse
    float sense_max_opp = max(forward_opp, max(left_opp, right_opp));
    if (sense_max_opp > spec.repulsionTreshold)
    {
        float repForce = spec.turnSpeed * random1 * (right_opp - left_opp);

        float g = max(sense_forward.g, max(sense_left.g, sense_right.g));
        if (agent.species == 0 && sense_max_opp == g)
            repForce = - repForce;

        angleDelta -= repForce;
    }
    
    agent.angle += angleDelta;   
    agent.position += vec2(spec.velocity*cos(agent.angle),spec.velocity*sin(agent.angle));
    torus(agent.position);
    agents[idx] = agent;
}

void write_color(uint idx)
{
    Agent agent = agents[idx];
    ivec2 pixelPos = ivec2(uint(agent.position.x), uint(agent.position.y));
    vec4 current = imageLoad(uStateImage, pixelPos);
    if (agent.species == 0)
        current.r = 1.0;
    else if (agent.species == 1)
        current.g = 1.0;
    else
        current.b = 1.0;
    imageStore(uStateImage, pixelPos, current); 
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;

    if (idx >=0 && idx < config.agentsCount) {

        update_one(idx);
        write_color(idx);
    }
}